<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permainan Ular & Kuis Calistung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8fafc;
            touch-action: none;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        
        #game-board {
            display: grid;
            background-color: #f0f9ff;
        }
        
        #game-over-screen {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .score-pill {
            border-radius: 8px;
            padding: 6px 12px;
            font-weight: 600;
            font-size: 14px;
            color: white;
        }
        
        .game-btn {
            transition: all 0.2s;
        }
        
        .game-btn:active {
            transform: translateY(2px);
        }
        
        .quiz-option {
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .quiz-option:hover {
            transform: translateY(-2px);
        }
        
        .feedback {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
            z-index: 10;
            text-shadow: 0px 0px 3px rgba(0,0,0,0.5);
        }
        
        @keyframes fadeUpAndOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-5xl flex flex-col md:flex-row gap-4">
        <!-- Quiz Section -->
        <div class="w-full md:w-2/5 bg-white p-6 rounded-xl shadow-md">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Kuis Calistung</h2>
            
            <div id="quiz-container" class="mb-6">
                <div class="mb-4">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">Pertanyaan:</h3>
                    <p id="question" class="text-xl font-semibold">Memuat pertanyaan...</p>
                </div>
                
                <div class="space-y-3">
                    <h3 class="text-lg font-medium text-gray-700">Pilihan:</h3>
                    <div id="options-container" class="grid grid-cols-1 gap-3">
                        <!-- Options will be inserted here -->
                    </div>
                </div>
            </div>
            
            <div class="text-sm text-gray-500">
                <p>Gunakan tombol panah untuk mengontrol ular</p>
                <p>Benar: +10 poin & ular bertambah panjang</p>
                <p>Salah: -10 poin & ular berkurang panjangnya</p>
                <p>Permainan berakhir jika skor mencapai 0!</p>
            </div>
        </div>
        
        <!-- Snake Game Section -->
        <div class="w-full md:w-3/5">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-bold text-gray-800">Permainan Ular</h1>
                <div class="flex gap-2">
                    <div class="score-pill bg-blue-500">Skor: <span id="score">60</span></div>
                    <div class="score-pill bg-red-500">Terbaik: <span id="high-score">0</span></div>
                </div>
            </div>
            
            <div id="game-container" class="w-full aspect-square mb-4 bg-blue-50">
                <canvas id="game-board" class="w-full h-full"></canvas>
                <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center hidden">
                    <h2 class="text-3xl font-bold text-white mb-2">Permainan Berakhir</h2>
                    <p id="game-over-reason" class="text-xl text-white mb-2">Skor Anda mencapai nol!</p>
                    <p class="text-xl text-white mb-6">Skor: <span id="final-score">0</span></p>
                    <button id="restart-btn" class="game-btn bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-6 rounded-lg">
                        Main Lagi
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game settings
            const GRID_SIZE = 20;
            const CELL_SIZE = 20;
            const GAME_SPEED = 150; // Normal speed
            const INITIAL_SCORE = 60; // Starting score
            const SEGMENTS_PER_SCORE = 10; // How many points per segment
            const MIN_SNAKE_LENGTH = 1; // Minimum snake length (head only)
            
            // Game elements
            const canvas = document.getElementById('game-board');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const highScoreElement = document.getElementById('high-score');
            const finalScoreElement = document.getElementById('final-score');
            const gameOverScreen = document.getElementById('game-over-screen');
            const gameOverReason = document.getElementById('game-over-reason');
            const restartBtn = document.getElementById('restart-btn');
            
            // Quiz elements
            const questionElement = document.getElementById('question');
            const optionsContainer = document.getElementById('options-container');
            
            // Game state
            let snake = [];
            let foods = [];
            let direction = 'right';
            let nextDirection = 'right';
            let score = INITIAL_SCORE;
            let highScore = localStorage.getItem('snakeHighScore') || 0;
            let gameInterval;
            let gameActive = false;
            
            // Quiz state
            let currentQuestion = null;
            let currentOptions = [];
            let correctAnswerIndex = -1;
            let usedQuestionIndices = [];
            
            // Colors for options
            const optionColors = [
                '#ef4444', // Red
                '#3b82f6', // Blue
                '#10b981', // Green
                '#f59e0b'  // Yellow
            ];
            
            // Quiz questions in Indonesian
            const quizQuestions = [
                {
                    type: 'math',
                    question: '5 + 3 = ?',
                    options: ['7', '8', '9', '10'],
                    correctIndex: 1
                },
                {
                    type: 'math',
                    question: '10 - 4 = ?',
                    options: ['4', '5', '6', '7'],
                    correctIndex: 2
                },
                {
                    type: 'math',
                    question: '3 × 3 = ?',
                    options: ['6', '8', '9', '12'],
                    correctIndex: 2
                },
                {
                    type: 'reading',
                    question: 'Kata mana yang berarti "hewan besar dengan belalai"?',
                    options: ['Singa', 'Gajah', 'Jerapah', 'Zebra'],
                    correctIndex: 1
                },
                {
                    type: 'reading',
                    question: 'Lengkapi: Langit berwarna ___',
                    options: ['biru', 'hijau', 'merah', 'kuning'],
                    correctIndex: 0
                },
                {
                    type: 'writing',
                    question: 'Manakah yang dieja dengan benar?',
                    options: ['Apel', 'Appel', 'Apell', 'Appell'],
                    correctIndex: 0
                },
                {
                    type: 'writing',
                    question: 'Huruf apa yang datang setelah "D"?',
                    options: ['C', 'E', 'F', 'B'],
                    correctIndex: 1
                },
                {
                    type: 'math',
                    question: '2 + 2 × 2 = ?',
                    options: ['6', '8', '4', '10'],
                    correctIndex: 0
                },
                {
                    type: 'reading',
                    question: 'Hewan mana yang bersuara "meong"?',
                    options: ['Anjing', 'Kucing', 'Burung', 'Ikan'],
                    correctIndex: 1
                },
                {
                    type: 'writing',
                    question: 'Berapa banyak huruf vokal dalam kata "GAJAH"?',
                    options: ['1', '2', '3', '4'],
                    correctIndex: 1
                },
                {
                    type: 'math',
                    question: '15 ÷ 3 = ?',
                    options: ['3', '5', '6', '7'],
                    correctIndex: 1
                },
                {
                    type: 'reading',
                    question: 'Manakah yang merupakan buah?',
                    options: ['Wortel', 'Kentang', 'Pisang', 'Brokoli'],
                    correctIndex: 2
                },
                {
                    type: 'writing',
                    question: 'Manakah kata yang dieja dengan benar?',
                    options: ['Cantik', 'Cantiq', 'Chantik', 'Cantikk'],
                    correctIndex: 0
                },
                {
                    type: 'math',
                    question: 'Berapakah 4² (4 kuadrat)?',
                    options: ['8', '12', '16', '20'],
                    correctIndex: 2
                },
                {
                    type: 'reading',
                    question: 'Manakah yang BUKAN warna?',
                    options: ['Merah', 'Biru', 'Meja', 'Hijau'],
                    correctIndex: 2
                }
            ];
            
            // Initialize the game
            function initGame() {
                // Set canvas size
                canvas.width = GRID_SIZE * CELL_SIZE;
                canvas.height = GRID_SIZE * CELL_SIZE;
                
                // Initialize score
                score = INITIAL_SCORE;
                scoreElement.textContent = score;
                highScoreElement.textContent = highScore;
                
                // Calculate initial snake length based on score
                const initialSnakeLength = Math.max(MIN_SNAKE_LENGTH, Math.floor(score / SEGMENTS_PER_SCORE));
                
                // Initialize snake with length based on starting score
                snake = [];
                for (let i = 0; i < initialSnakeLength; i++) {
                    snake.push({x: 10 - i, y: 10});
                }
                
                // Initialize direction
                direction = 'right';
                nextDirection = 'right';
                
                // Clear foods
                foods = [];
                
                // Reset used questions
                usedQuestionIndices = [];
                
                // Load a question
                loadRandomQuestion();
                
                // Hide game over screen
                gameOverScreen.classList.add('hidden');
                
                // Start game loop
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, GAME_SPEED);
                gameActive = true;
            }
            
            // Load a random question
            function loadRandomQuestion() {
                // Clear existing foods
                foods = [];
                
                // If we've used all questions, reset the used indices
                if (usedQuestionIndices.length >= quizQuestions.length) {
                    usedQuestionIndices = [];
                }
                
                // Find an unused question
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * quizQuestions.length);
                } while (usedQuestionIndices.includes(randomIndex));
                
                // Mark this question as used
                usedQuestionIndices.push(randomIndex);
                
                currentQuestion = quizQuestions[randomIndex];
                currentOptions = currentQuestion.options;
                correctAnswerIndex = currentQuestion.correctIndex;
                
                // Display the question
                questionElement.textContent = currentQuestion.question;
                
                // Clear previous options
                optionsContainer.innerHTML = '';
                
                // Display options and create corresponding food
                currentOptions.forEach((option, index) => {
                    const color = optionColors[index];
                    
                    // Create option element
                    const optionElement = document.createElement('div');
                    optionElement.className = `quiz-option p-3 rounded-lg flex items-center`;
                    optionElement.style.backgroundColor = color + '20'; // Light version of the color
                    optionElement.style.borderLeft = `4px solid ${color}`;
                    
                    optionElement.innerHTML = `
                        <div class="w-4 h-4 rounded-full mr-3" style="background-color: ${color}"></div>
                        <span class="font-medium">${option}</span>
                    `;
                    
                    optionsContainer.appendChild(optionElement);
                    
                    // Generate food position
                    let foodPosition = generateFoodPosition();
                    
                    // Add food
                    foods.push({
                        x: foodPosition.x,
                        y: foodPosition.y,
                        color: color,
                        optionIndex: index,
                        isCorrect: index === correctAnswerIndex
                    });
                });
            }
            
            // Generate a valid food position
            function generateFoodPosition() {
                let newPosition;
                let validPosition = false;
                
                while (!validPosition) {
                    newPosition = {
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    };
                    
                    validPosition = true;
                    
                    // Check if position is on snake
                    for (let i = 0; i < snake.length; i++) {
                        if (snake[i].x === newPosition.x && snake[i].y === newPosition.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check if position is on other foods
                    for (let i = 0; i < foods.length; i++) {
                        if (foods[i].x === newPosition.x && foods[i].y === newPosition.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                return newPosition;
            }
            
            // Game loop
            function gameLoop() {
                // Update direction
                direction = nextDirection;
                
                // Move snake
                const head = {x: snake[0].x, y: snake[0].y};
                
                switch (direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                }
                
                // Check collision with walls
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    gameOver("Anda menabrak dinding!");
                    return;
                }
                
                // Check collision with self
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === head.x && snake[i].y === head.y) {
                        gameOver("Anda menabrak diri sendiri!");
                        return;
                    }
                }
                
                // Check collision with food
                let ate = false;
                let foodIndex = -1;
                
                for (let i = 0; i < foods.length; i++) {
                    if (head.x === foods[i].x && head.y === foods[i].y) {
                        foodIndex = i;
                        ate = true;
                        break;
                    }
                }
                
                if (ate) {
                    const eatenFood = foods[foodIndex];
                    
                    // Update score based on whether the answer was correct
                    if (eatenFood.isCorrect) {
                        score += 10; // Points for correct answers
                        showFeedback(eatenFood.x, eatenFood.y, "+10", "#10b981");
                    } else {
                        score = Math.max(0, score - 10); // Subtract points for wrong answers
                        showFeedback(eatenFood.x, eatenFood.y, "-10", "#ef4444");
                        
                        // Check if score reached zero
                        if (score === 0) {
                            gameOver("Skor Anda mencapai nol!");
                            return;
                        }
                    }
                    
                    scoreElement.textContent = score;
                    
                    // Immediately load a new question
                    loadRandomQuestion();
                }
                
                // Move snake
                snake.unshift(head);
                
                // Calculate target snake length based on score
                // Ensure at least MIN_SNAKE_LENGTH segments (head only)
                const targetLength = Math.max(MIN_SNAKE_LENGTH, Math.floor(score / SEGMENTS_PER_SCORE));
                
                // Adjust snake length based on target length
                if (snake.length > targetLength) {
                    // Remove tail segments until we reach the target length
                    while (snake.length > targetLength) {
                        snake.pop();
                    }
                } else if (snake.length < targetLength && ate && eatenFood.isCorrect) {
                    // Don't remove the tail if we're growing from eating correct food
                    // The head was already added, so we don't need to do anything else
                } else if (!ate) {
                    // Normal movement (no growth) - remove tail if we have more than MIN_SNAKE_LENGTH segments
                    if (snake.length > MIN_SNAKE_LENGTH) {
                        snake.pop();
                    }
                }
                
                // Draw game
                drawGame();
            }
            
            // Show feedback (+10/-10) at the position
            function showFeedback(x, y, text, color) {
                const feedback = document.createElement('div');
                feedback.className = 'feedback';
                feedback.textContent = text;
                feedback.style.color = color;
                feedback.style.left = `${x * CELL_SIZE + CELL_SIZE/2}px`;
                feedback.style.top = `${y * CELL_SIZE}px`;
                feedback.style.transform = 'translate(-50%, 0)';
                
                // Add to game container
                const gameContainer = document.getElementById('game-container');
                gameContainer.appendChild(feedback);
                
                // Animate
                setTimeout(() => {
                    feedback.style.opacity = '1';
                    feedback.style.animation = 'fadeUpAndOut 1s forwards';
                    
                    // Remove after animation
                    setTimeout(() => {
                        gameContainer.removeChild(feedback);
                    }, 1000);
                }, 10);
            }
            
            // Draw game
            function drawGame() {
                // Clear canvas
                ctx.fillStyle = '#f0f9ff'; // Light blue background
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw subtle grid
                ctx.strokeStyle = '#e0f2fe';
                ctx.lineWidth = 0.5;
                
                for (let i = 0; i <= GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE, 0);
                    ctx.lineTo(i * CELL_SIZE, canvas.height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL_SIZE);
                    ctx.lineTo(canvas.width, i * CELL_SIZE);
                    ctx.stroke();
                }
                
                // Draw snake
                snake.forEach((segment, index) => {
                    if (index === 0) {
                        // Draw head as square
                        ctx.fillStyle = '#10b981'; // Green
                        ctx.fillRect(
                            segment.x * CELL_SIZE, 
                            segment.y * CELL_SIZE, 
                            CELL_SIZE, 
                            CELL_SIZE
                        );
                        
                        // Draw eyes
                        ctx.fillStyle = 'white';
                        const eyeSize = CELL_SIZE / 5;
                        const eyeOffset = CELL_SIZE / 4;
                        
                        // Position eyes based on direction
                        let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                        
                        switch (direction) {
                            case 'up':
                                leftEyeX = segment.x * CELL_SIZE + eyeOffset;
                                leftEyeY = segment.y * CELL_SIZE + eyeOffset;
                                rightEyeX = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                rightEyeY = segment.y * CELL_SIZE + eyeOffset;
                                break;
                            case 'down':
                                leftEyeX = segment.x * CELL_SIZE + eyeOffset;
                                leftEyeY = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                rightEyeX = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                rightEyeY = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                break;
                            case 'left':
                                leftEyeX = segment.x * CELL_SIZE + eyeOffset;
                                leftEyeY = segment.y * CELL_SIZE + eyeOffset;
                                rightEyeX = segment.x * CELL_SIZE + eyeOffset;
                                rightEyeY = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                break;
                            case 'right':
                                leftEyeX = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                leftEyeY = segment.y * CELL_SIZE + eyeOffset;
                                rightEyeX = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                rightEyeY = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset - eyeSize;
                                break;
                        }
                        
                        ctx.fillRect(leftEyeX, leftEyeY, eyeSize, eyeSize);
                        ctx.fillRect(rightEyeX, rightEyeY, eyeSize, eyeSize);
                        
                    } else {
                        // Draw body as rounded squares
                        ctx.fillStyle = '#34d399'; // Light green
                        const padding = 1;
                        const radius = 2;
                        
                        ctx.beginPath();
                        ctx.roundRect(
                            segment.x * CELL_SIZE + padding, 
                            segment.y * CELL_SIZE + padding, 
                            CELL_SIZE - padding * 2, 
                            CELL_SIZE - padding * 2,
                            radius
                        );
                        ctx.fill();
                    }
                });
                
                // Draw foods
                foods.forEach(food => {
                    // Draw food as circle with the option color
                    ctx.fillStyle = food.color;
                    const foodRadius = CELL_SIZE / 2 - 1;
                    ctx.beginPath();
                    ctx.arc(
                        food.x * CELL_SIZE + CELL_SIZE/2,
                        food.y * CELL_SIZE + CELL_SIZE/2,
                        foodRadius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
            
            // Game over
            function gameOver(reason) {
                clearInterval(gameInterval);
                gameActive = false;
                
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    highScoreElement.textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }
                
                // Show game over screen
                gameOverReason.textContent = reason || "Permainan Berakhir";
                finalScoreElement.textContent = score;
                gameOverScreen.classList.remove('hidden');
            }
            
            // Handle keyboard input
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowUp':
                        if (direction !== 'down') nextDirection = 'up';
                        break;
                    case 'ArrowDown':
                        if (direction !== 'up') nextDirection = 'down';
                        break;
                    case 'ArrowLeft':
                        if (direction !== 'right') nextDirection = 'left';
                        break;
                    case 'ArrowRight':
                        if (direction !== 'left') nextDirection = 'right';
                        break;
                }
            });
            
            // Handle restart button
            restartBtn.addEventListener('click', initGame);
            
            // Handle swipe gestures
            let touchStartX = 0;
            let touchStartY = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Determine swipe direction
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 0 && direction !== 'left') {
                        nextDirection = 'right';
                    } else if (diffX < 0 && direction !== 'right') {
                        nextDirection = 'left';
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 0 && direction !== 'up') {
                        nextDirection = 'down';
                    } else if (diffY < 0 && direction !== 'down') {
                        nextDirection = 'up';
                    }
                }
                
                e.preventDefault();
            }, { passive: false });
            
            // Set high score from local storage
            highScoreElement.textContent = highScore;
            
            // Polyfill for roundRect if not supported
            if (!CanvasRenderingContext2D.prototype.roundRect) {
                CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.beginPath();
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    this.closePath();
                    return this;
                };
            }
            
            // Start the game
            initGame();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9668950f049afd1f',t:'MTc1Mzc0OTgwOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
